validate_file() {
    local file="$1"

    # Read the first line (HEADER)
    header=$(head -n 1 "$file")
    
    # Read the last line (FOOTER)
    footer=$(tail -n 1 "$file")

    # Extract expected record count from footer (number after "FOOTER")
    record_count=$(echo "$footer" | awk '{print $2}')

    # Count actual data lines (excluding header and footer)
    actual_count=$(sed '1d;$d' "$file" | wc -l)

    # Check for bad record (line with only delimiters ~)
    bad_record=$(sed '1d;$d' "$file" | grep -E '^~+ *~*$')

    if [[ "$record_count" -eq 1 && "$actual_count" -eq 1 && -n "$bad_record" ]]; then
    echo "Bad file detected"
fi


# Validation checks
    if [[ ! "$header" =~ ^\"HEADER\"[[:space:]][0-9]{8}$ ]]; then
        echo "BAD FILE: Header is incorrect"
    elif [[ ! "$footer" =~ ^\"FOOTER\"[[:space:]][0-9]+$ ]]; then
        echo "BAD FILE: Footer is incorrect"
    elif [[ $actual_count -eq 0 ]]; then
        echo "BAD FILE: No valid records found"
    elif [[ -n "$bad_record" ]]; then
        echo "BAD FILE: Contains empty delimiter-only record"
    elif [[ "$actual_count" -ne "$record_count" ]]; then
        echo "BAD FILE: Footer count ($record_count) does not match actual records ($actual_count)"
    else
        echo "GOOD FILE"
    fi
}

#!/bin/bash

# Define the variable that controls the replacement
variable_value=1  # Change this to test

# Define the command (multi-line for readability)
cmd="${perldir}/tse_script.p \
  -A param1 \
  -B param2 \
  -S {tp} \
  -X paramX \
  -M {tpsfile_sus} \
  -Y paramY \
  -Z paramZ"

# Replace `-M {tpsfile_sus}` with `-M NA` if variable_value is 1
if [ "$variable_value" -eq 1 ]; then
    cmd=${cmd//"-M {tpsfile_sus}"/"-M NA"}  # String replacement
fi

# Print and execute the final command
echo "Running: $cmd"
eval "$cmd"



log_message() { 
    echo "[$(date +"%Y-%m-%d %H:%M:%S")] [$1] $2" | tee -a script.log; 
}

# Usage
log_message "INFO" "Script started."
log_message "ERROR" "File not found!"



#!/usr/bin/perl
use strict;
use warnings;

# Check if exactly 5 parameters are provided
if (@ARGV != 5) {
    die "Usage: $0 param1 param2 param3 param4 param5\n";
}

# Assign parameters to variables
my ($param1, $param2, $param3, $param4, $param5) = @ARGV;

# Print parameters
print "Hello, World!\n";
print "Parameter 1: $param1\n";
print "Parameter 2: $param2\n";
print "Parameter 3: $param3\n";
print "Parameter 4: $param4\n";
print "Parameter 5: $param5\n";



validate_file() {
    local file="$1"
    local header footer record_count actual_count bad_record

    # Read the first line (HEADER) without trimming spaces
    header=$(head -n 1 "$file")
    
    # Read the last line (FOOTER) without trimming spaces
    footer=$(tail -n 1 "$file")

    # Extract expected record count from footer (number after "FOOTER")
    record_count=$(echo "$footer" | awk '{print $2}')

    # If record_count is greater than 1, skip validation
    if [[ "$record_count" -gt 1 ]]; then
        echo "No validation needed: Footer record count is greater than 1."
        return
    fi

    # If record_count is 1 or less, check if the records contain only delimiters
    # Count actual data lines (excluding header and footer), trimming spaces from records
    actual_count=$(sed '1d;$d' "$file" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | wc -l)

    # Check for bad record (line with only delimiters ~), trimming spaces from records
    bad_record=$(sed '1d;$d' "$file" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -E '^~+$')

    # Check if the file only contains delimiters and no valid records
    if [[ "$actual_count" -eq 1 && -n "$bad_record" ]]; then
        echo "BAD FILE: Contains only invalid record (delimiters only)"
        return
    elif [[ "$actual_count" -lt 1 ]]; then
        echo "BAD FILE: No valid records found (empty or invalid records)"
        return
    fi

    # Validation checks if the record count is 1 or less
    if [[ ! "$header" =~ ^\"HEADER\"[[:space:]][0-9]{8}$ ]]; then
        echo "BAD FILE: Header is incorrect"
    elif [[ ! "$footer" =~ ^\"FOOTER\"[[:space:]][0-9]+$ ]]; then
        echo "BAD FILE: Footer is incorrect"
    elif [[ "$actual_count" -ne "$record_count" ]]; then
        echo "BAD FILE: Footer count ($record_count) does not match actual records ($actual_count)"
    else
        echo "GOOD FILE"
    fi
}



"HEADER" 20250328
         ~     ~1234            ~              ~~ ~ ~     ~ ~ ~
"FOOTER" 1